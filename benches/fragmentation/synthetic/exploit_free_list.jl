include(joinpath("..", "..", "..", "util", "utils.jl"))

mutable struct ListNode{N}
    next::Union{ListNode{N}, Nothing}
    data::NTuple{N, UInt8}
end

@static if Sys.WORD_SIZE != 64
    error("This script requires a 64-bit version of Julia")
end
const NEXT_PTR_BYTES = 8
const JL_HEADER_BYTES = 8

@inline function create_node(::Val{N}) where N
    # N is now compile-time known
    ListNode{N}(nothing, ntuple(_ -> UInt8(0), Val(N)))
end

# These constants are specific to Julia's pool allocator. If Julia changes the implementation, these value may need to be updated.
const JL_GC_SIZECLASS = [8, 16, 24, 32, 40, 48, 56, 64, 72, 80, 88, 96, 104, 112, 120, 128, 136, 144, 160, 176, 192, 208, 224, 240, 256, 272, 288, 304, 336, 368, 400, 448, 496, 544, 576, 624, 672, 736, 816, 896, 1008, 1088, 1168, 1248, 1360, 1488, 1632, 1808, 2032]
const N_SIZE_CLASSES = length(JL_GC_SIZECLASS)
const PAGE_SIZE = 16384

# These constants are configurable
# How many pages to allocate for each size class
const PAGES_TO_ALLOCATE = 10240
# The keep alive pattern for the allocated pool objects
# 1 = keep one object alive per page
# 2 = keep every other objects alive
const KEEP_ALIVE_PATTERN = 2

const KEPT_LISTS = []

function process_size_class(sz_class_index::Int, sz::Int)
    payload_sz = sz - JL_HEADER_BYTES
    tuple_len = payload_sz - NEXT_PTR_BYTES
    T = Val(tuple_len)
    if tuple_len <= 0
        return
    end
    objs_per_page = div(PAGE_SIZE, sz)
    total_objs = Int64(PAGES_TO_ALLOCATE * objs_per_page)

    actual_sz = sizeof(ListNode{tuple_len})
    actual_sz + JL_HEADER_BYTES == sz || error("Actual size does not match expected size")

    println("Processing size class $sz")
    println("  Actual payload size: $actual_sz bytes, N: $tuple_len")
    println("  Allocating $total_objs objects")

    print_page_utilization("Before", sz_class_index)

    # Create initial linked list
    head = create_list(total_objs, T)
    n_nodes(head) == total_objs || error("Actual number of objects does not match total_objs")

    print_page_utilization("Alloc", sz_class_index)

    # Fragment the linked list
    new_head = fragment_list(head, objs_per_page)
    # Preserve remaining objects
    global KEPT_LISTS
    push!(KEPT_LISTS, new_head)

    print_page_utilization("Fragment", sz_class_index)
end

function create_list(total_objs::Int64, T::Val)
    # We need to be careful that the loop does not introduce allocations
    head = current = create_node(T)
    i = 2
    while true
        current.next = create_node(T)
        current = current.next
        i += 1
        i > total_objs && break
    end
    return head
end

function fragment_list(head::ListNode, objs_per_page::Int)
    new_head = head
    last = head
    current = head
    counter = 1
    while !isnothing(current) && !isnothing(current.next)
        next = current.next
        # If pattern == 1, keep one object alive per page
        # If pattern == 2, keep every other object alive
        if (KEEP_ALIVE_PATTERN == 1 && mod(counter, objs_per_page) == 0) || (KEEP_ALIVE_PATTERN == 2 && mod(counter, 2) == 0)
            last.next = current
            last = current
        end
        current = next
        counter += 1
    end
    return new_head
end

function n_nodes(node::ListNode)
    count = 0
    current = node
    while !isnothing(current)
        count += 1
        current = current.next
    end
    return count
end

function print_page_utilization(msg::String, sz_class_index::Int)
    GC.gc(true)
    utils = Base.gc_page_utilization_data()

    for (i, sz) in enumerate(JL_GC_SIZECLASS)
        if sz_class_index == -1 || i == sz_class_index
            println("    $(lpad(msg, 10)): Pool $i: $(round(utils[i]*100, digits=2))%")
        end
    end
end

function main()
    for (i,sz) in enumerate(JL_GC_SIZECLASS)
        # Julia aligns up object size to 16 bytes. We only allocate if the size class is 16 bytes aligned.
        if mod(sz, 16) != 0
            continue
        end
        process_size_class(i, sz)
    end

    println("\nFragmentation complete.")
    print_page_utilization("Final", -1)

    sum = 0
    println("Kept lists: $(length(KEPT_LISTS))")
    for l in KEPT_LISTS
        println("  List length: $(n_nodes(l))")
        sum += n_nodes(l)
    end
    println("Total live objects: $sum")
end

@gctime main()
